# Generated by Django 5.0.7 on 2024-10-23 07:33

from django.db import migrations, models
from django.db.models import Count
from django.db import transaction
import logging

logger = logging.getLogger(__name__)


def deduplicate_names(apps, schema_editor):
    CatalogueEntry = apps.get_model('catalogue', 'CatalogueEntry')
    db_alias = schema_editor.connection.alias
    
    with transaction.atomic():
        # Find duplicates
        duplicates = (
            CatalogueEntry.objects.using(db_alias)
            .values('name')
            .annotate(name_count=Count('name'))
            .filter(name_count__gt=1)
        )
        
        # Process each set of duplicates
        for duplicate in duplicates:
            name = duplicate['name']
            entries = CatalogueEntry.objects.using(db_alias).filter(name=name).order_by('id')
            
            # Skip the first one (keep original)
            for index, entry in enumerate(entries[1:], 1):
                new_name = f"{name} ({index})"
                logger.info(f"Renaming duplicate entry ID {entry.id} from '{name}' to '{new_name}'")
                entry.name = new_name
                entry.save()

def reverse_migration(apps, schema_editor):
    # Cannot reliably reverse this migration as we don't know which entries were modified
    logger.warning("Reverting deduplicate_names migration - unique constraint will be removed but data will remain modified")
    pass

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0042_alter_catalogueentrypermission_catalogue_entry'),
    ]

    operations = [
        # First, run the deduplication
        migrations.RunPython(
            deduplicate_names,
            reverse_code=reverse_migration
        ),
        migrations.AlterField(
            model_name='catalogueentry',
            name='name',
            field=models.TextField(unique=True),
        ),
    ]
